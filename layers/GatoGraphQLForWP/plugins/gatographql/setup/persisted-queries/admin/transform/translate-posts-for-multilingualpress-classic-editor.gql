########################################################################
# 
# Variables:
#   - $username: The username to log into the external site
#   - $appPassword: The application password to log into the external site
#   - $externalSiteURL: The URL of the external site, where all pages will be (translated and) created
#   - postId: The post with the origin language, from where all translations will be made
#   - statusToUpdate: The status the translation posts must have to be updated. It is `draft` by default. Pass `any` for any status.
#   - updateSlug: Indicate if to update the post slug, using the translated title. It is `true` by default.
#   - includeLanguagesToTranslate: Limit languages to execute the translation for. If empty, all languages are included
#   - excludeLanguagesToTranslate: Exclude languages from executing the translation
#   - languageMapping: JSON object to convert languages codes to work with Google Translate. For instance, WordPress uses "nb" as the code for Norwegian, but Google Translate uses "no" instead; to translate to Norwegian, then pass value `{"nb": "no"}`
#   - (Optional) $externalSiteGraphQLEndpointPath: Path to the GraphQL endpoint on the external site
#
# *********************************************************************
#
# === Description ===
#
# This Persisted GraphQL query is an integration for MultilingualPress,
# to translate posts based on the Classic editor, where very site in a
# WordPress multisite network is a translationsite.
# 
# It must be executed on the master site, which must have the PRO plugin.
# All other sites in the network can have the free Gato GraphQL plugin.
#
# It takes an origin post on the master site, it translates it using the
# Google Translate API to all the other languages defined as connections
# in MultilingualPress, and stores those translations in the corresponding
# sites in the network.
#
# All translation posts in all the network sites must already exist.
# These posts must also have the  `draft` status
# to be updated. To update posts with any other status, use
# variable `$statusToUpdate` (for instance, passing value
# `publish`, `pending` or `any`)
#
# To limit for what languages to execute the translation, pass
# variables `$includeLanguagesToTranslate` (if empty, all languages
# will be included) and `$excludeLanguagesToTranslate`.
#
# By default it also translates the post slug. To disable, pass
# variable `updateSlug` with `false`.
#
# For some languages, the code used by WordPress and Google Translate
# are different. For instance, Norwegian is represented as "nb" by
# WordPress, and as "no" by Google Translate. To support translating
# to these languages, provide the language code mapping via the
# `$languageMapping` GraphQL variable, such as:
#
#   {
#     "languageMapping": {
#       "nb": "no"
#     }
#   }
#
# See Persisted Query "Translate post (Classic editor)" for additional
# documentation.
#
########################################################################
query InitializeExternalSiteVariables
  @configureWarningsOnExportingDuplicateVariable(enabled: false)
{
  emptyBool: _echo(value: false)
    @export(as: "executeTranslation")
    @remove
}

query ExportData(
  $username: String!
  $appPassword: String!
  $externalSiteURL: URL!
  $externalSiteGraphQLEndpointPath: String! = "/graphql/internal/"
)
  @depends(on: "InitializeExternalSiteVariables")
{
  # Retrieve the language of the content
  siteLanguage
    @export(as: "fromLanguage")

  # Generate the authorization header to connect to the external site
  loginCredentials: _sprintf(
    string: "%s:%s",
    values: [$username, $appPassword]
  )
    @remove
  base64EncodedLoginCredentials: _strBase64Encode(
    string: $__loginCredentials
  )
    @remove
  authorizationHeaderValue: _sprintf(
    string: "Basic %s",
    values: [$__base64EncodedLoginCredentials]
  )
    @remove
    @export(as: "authorizationHeaderValue")
  
  # Generate the external site's GraphQL endpoint to connect to
  endpoint: _sprintf(
    string: "%s%s",
    values: [
      $externalSiteURL,
      $externalSiteGraphQLEndpointPath
    ]
  )
    @export(as: "endpoint")
}

query ExportOriginPost(
  $postId: ID!
  $includeLanguagesToTranslate: [String!]
  $excludeLanguagesToTranslate: [String!]
)
  @depends(on: "ExportData")
{
  originPost: post(by: { id: $postId }, status: any) {
    id
    

    multilingualpressTranslationConnections(filter: {
      includeLanguages: $includeLanguagesToTranslate
      excludeLanguages: $excludeLanguagesToTranslate
    }) {
      siteID
      postID: entityID
        @export(
          as: "translationPostIds",
          type: LIST
        )
    }

    hasTranslationPosts: _notEmpty(value: $__multilingualpressTranslationConnections)
      @export(as: "hasTranslationPosts")


    title
      @export(as: "originTitle")
    rawContent
      @export(as: "originRawContent")
    rawExcerpt
      @export(as: "originRawExcerpt")
  }

  hasOriginPost: _notNull(value: $__originPost)
    @export(as: "hasOriginPost")
}

query RetrieveAndExportExternalSiteLanguage
  @depends(on: "ExportOriginPost")
  @include(if: $hasOriginPost)
{
  # Retrieve the language of the external site
  externalHTTPRequest: _sendGraphQLHTTPRequest(input:{
    endpoint: $endpoint,
    query: """
  
{
  me {
    name
  }
  siteLanguage
}

    """,
    options: {
      headers: [
        {
          name: "Authorization",
          value: $authorizationHeaderValue
        }
      ]
    }
  })
  externalSiteLanguage: _objectProperty(
    object: $__externalHTTPRequest,
    by: {
      path: "data.siteLanguage"
    }
  )
    @export(as: "toLanguage")
  
  # Indicate if connecting to the external site was successful
  hasRetrievedExternalSiteLanguage: _notEmpty(
    value: $__externalSiteLanguage
  )

  # Only translate the content if the master/destination sites languages are different
  areFromToLanguagesDifferent: _notEquals(
    value1: $fromLanguage
    value2: $__externalSiteLanguage
  )

  # Flag to indicate if to translate the content
  executeTranslation: _and(
    values: [
      $__hasRetrievedExternalSiteLanguage,
      $__areFromToLanguagesDifferent,
    ]
  )
    @export(as: "executeTranslation")
}

query FetchData(
  $pageIDs: [ID!]! = []
  $pageStatus: [CustomPostStatusEnum!]! = [publish]
)
  @depends(on: "RetrieveAndExportExternalSiteLanguage")
  @include(if: $hasMasterPages)
{
  fetchDataPages: pages(filter: { ids: $pageIDs, status: $pageStatus }) {
    id


    title
      @export(
        as: "title"
        type: DICTIONARY
      )
    rawContent
      @export(
        as: "rawContent"
        type: DICTIONARY
      )
    rawExcerpt
      @export(
        as: "rawExcerpt"
        type: DICTIONARY
      )
  }
}

query AdaptData
  @depends(on: "FetchData")
  @include(if: $hasMasterPages)
{
  adaptedToTitle: _echo(value: $title)
    @underEachJSONObjectProperty(
      passValueOnwardsAs: "value"
    )
      @applyField(
        name: "_echo"
        arguments: {
          value: [$value]
        }
        setResultInResponse: true
      )
    @export(as: "adaptedToTitle")
  adaptedFromTitle: _echo(value: $title)
    @underEachJSONObjectProperty
      @applyField(
        name: "_echo"
        arguments: {
          value: [""]
        }
        setResultInResponse: true
      )
    @export(as: "adaptedFromTitle")

  adaptedToRawContent: _echo(value: $rawContent)
    @underEachJSONObjectProperty(
      passValueOnwardsAs: "value"
    )
      @applyField(
        name: "_echo"
        arguments: {
          value: [$value]
        }
        setResultInResponse: true
      )
    @export(as: "adaptedToRawContent")
  adaptedFromRawContent: _echo(value: $rawContent)
    @underEachJSONObjectProperty
      @applyField(
        name: "_echo"
        arguments: {
          value: [""]
        }
        setResultInResponse: true
      )
    @export(as: "adaptedFromRawContent")

  adaptedToRawExcerpt: _echo(value: $rawExcerpt)
    @underEachJSONObjectProperty(
      passValueOnwardsAs: "value"
    )
      @applyField(
        name: "_echo"
        arguments: {
          value: [$value]
        }
        setResultInResponse: true
      )
    @export(as: "adaptedToRawExcerpt")
  adaptedFromRawExcerpt: _echo(value: $rawExcerpt)
    @underEachJSONObjectProperty
      @applyField(
        name: "_echo"
        arguments: {
          value: [""]
        }
        setResultInResponse: true
      )
    @export(as: "adaptedFromRawExcerpt")
}

query TransformData
  @depends(on: "AdaptData")
  @include(if: $hasMasterPages)
{
  transformations: _echo(value: {
    metaTitle: {
      from: $adaptedFromTitle,
      to: $adaptedToTitle,
    },
    metaRawContent: {
      from: $adaptedFromRawContent,
      to: $adaptedToRawContent,
    },
    metaRawExcerpt: {
      from: $adaptedFromRawExcerpt,
      to: $adaptedToRawExcerpt,
    }
  })
    @if(condition: $executeTranslation)
      @underEachJSONObjectProperty
        @underJSONObjectProperty(by: { key: "to" })
          @underEachJSONObjectProperty
            @underEachArrayItem
              @strTranslate(
                from: $fromLanguage,
                to: $toLanguage
              )
    @export(as: "transformations")
}

query PrepareMetaReplacements
  @depends(on: "TransformData")
  @include(if: $hasMasterPages)
{
  transformedMetaTitle: _echo(value: $title)
    @underEachJSONObjectProperty(
      passKeyOnwardsAs: "pageID"
      affectDirectivesUnderPos: [1, 2, 3]
    )
      @applyField(
        name: "_sprintf",
        arguments: {
          string: "metaTitle.to.%s",
          values: [$pageID]
        }
        passOnwardsAs: "titlePath"
      )
      @applyField(
        name: "_objectProperty",
        arguments: {
          object: $transformations
          by: { path: $titlePath }
        }
        passOnwardsAs: "transformedPostTitleAsArray"
      )
      @applyField(
        name: "_arrayItem",
        arguments: {
          array: $transformedPostTitleAsArray
          position: 0
        }
        setResultInResponse: true
      )
    @export(
      as: "transformedTitle"
    )

  transformedMetaRawContent: _echo(value: $rawContent)
    @underEachJSONObjectProperty(
      passKeyOnwardsAs: "pageID"
      affectDirectivesUnderPos: [1, 2, 3]
    )
      @applyField(
        name: "_sprintf",
        arguments: {
          string: "metaRawContent.to.%s",
          values: [$pageID]
        }
        passOnwardsAs: "rawContentPath"
      )
      @applyField(
        name: "_objectProperty",
        arguments: {
          object: $transformations
          by: { path: $rawContentPath }
        }
        passOnwardsAs: "transformedPostRawContentAsArray"
      )
      @applyField(
        name: "_arrayItem",
        arguments: {
          array: $transformedPostRawContentAsArray
          position: 0
        }
        setResultInResponse: true
      )
    @export(
      as: "transformedRawContent"
    )

  transformedMetaRawExcerpt: _echo(value: $rawExcerpt)
    @underEachJSONObjectProperty(
      passKeyOnwardsAs: "pageID"
      affectDirectivesUnderPos: [1, 2, 3]
    )
      @applyField(
        name: "_sprintf",
        arguments: {
          string: "metaRawExcerpt.to.%s",
          values: [$pageID]
        }
        passOnwardsAs: "rawExcerptPath"
      )
      @applyField(
        name: "_objectProperty",
        arguments: {
          object: $transformations
          by: { path: $rawExcerptPath }
        }
        passOnwardsAs: "transformedPostRawExcerptAsArray"
      )
      @applyField(
        name: "_arrayItem",
        arguments: {
          array: $transformedPostRawExcerptAsArray
          position: 0
        }
        setResultInResponse: true
      )
    @export(
      as: "transformedRawExcerpt"
    )
}

query ExportMutationInputs(
  $pageIDs: [ID!]! = []
  $pageStatus: [CustomPostStatusEnum!]! = [publish]
)
  @depends(on: "PrepareMetaReplacements")
  @include(if: $hasMasterPages)
{
  exportPages: pages(filter: { ids: $pageIDs, status: $pageStatus }) {
    id
    transformedRawContent: _objectProperty(
      object: $transformedRawContent,
      by: {
        key: $__id
      }
    )
    transformedTitle: _objectProperty(
      object: $transformedTitle,
      by: {
        key: $__id
      }
    )
    transformedSlug: _echo(value: $__transformedTitle)
    transformedRawExcerpt: _objectProperty(
      object: $transformedRawExcerpt,
      by: {
        key: $__id
      }
    )
    input: _echo(value: {
      status: draft,
      title: $__transformedTitle,
      slug: $__transformedSlug,
      excerpt: $__transformedRawExcerpt,
      contentAs: {
        html: $__transformedRawContent
      }
    })
      @export(
        as: "createPostMutationInputs"
        type: LIST
      )
  }
}

mutation CreatePagesWithTranslationOnExternalSite
  @depends(on: "ExportMutationInputs")
  @include(if: $hasMasterPages)
{
  createExternalSitePageHTTPRequests: _echo(value: $createPostMutationInputs)
    @underEachArrayItem(
      passValueOnwardsAs: "input"
    )
      @applyField(
        name: "_sendGraphQLHTTPRequest"
        arguments: {
          input: {
            endpoint: $endpoint,
            query: """
          
mutation CreatePageFromMasterSite($input: JSONObject!) {
  createPage(input: $input) {
    status
    errors {
      __typename
      ...on ErrorPayload {
        message
      }
    }
    page {
      id
      slug
      title
      content
      status
      url
      excerpt
    }
  }
}

            """,
            variables: [
              {
                name: "input",
                value: $input
              }
            ],
            options: {
              headers: [
                {
                  name: "Authorization",
                  value: $authorizationHeaderValue
                }
              ]
            }
          }
        },
        setResultInResponse: true
      )
}










query InitializeVariables
  @configureWarningsOnExportingDuplicateVariable(enabled: false)
{
  emptyBool: _echo(value: false)
    @export(as: "hasTranslationPosts")
    @export(as: "executeTranslation")
    @remove
  
  emptyArray: _echo(value: [])
    @export(as: "translationPostIds")
}

query ExportOriginPost(
  $postId: ID!
  $includeLanguagesToTranslate: [String!]
  $excludeLanguagesToTranslate: [String!]
)
  @depends(on: "InitializeVariables")
{
  siteLanguage
    @export(as: "fromLanguage")

  originPost: post(by: { id: $postId }, status: any) {
    id
    

    multilingualpressTranslationConnections(filter: {
      includeLanguages: $includeLanguagesToTranslate
      excludeLanguages: $excludeLanguagesToTranslate
    }) {
      siteID
      postID: entityID
        @export(
          as: "translationPostIds",
          type: LIST
        )
    }

    hasTranslationPosts: _notEmpty(value: $__multilingualpressTranslationConnections)
      @export(as: "hasTranslationPosts")


    title
      @export(as: "originTitle")
    rawContent
      @export(as: "originRawContent")
    rawExcerpt
      @export(as: "originRawExcerpt")
  }

  hasOriginPost: _notNull(value: $__originPost)
    @export(as: "hasOriginPost")
}

query FetchData(
  $statusToUpdate: CustomPostStatusEnum! = draft
)
  @depends(on: "ExportOriginPost")
  @include(if: $hasOriginPost)
  @include(if: $hasTranslationPosts)
{
  translationPosts: posts(filter: { ids: $translationPostIds, status: $statusToUpdate } ) {
    id

    polylangLanguage
      @export(
        as: "translationPostLanguages"
        type: DICTIONARY
      )

    title: _echo(value: $originTitle)
    rawContent: _echo(value: $originRawContent)
    rawExcerpt: _echo(value: $originRawExcerpt)
      @export(
        as: "dataToTranslate",
        affectAdditionalFieldsUnderPos: [1, 2]
        type: DICTIONARY
      )
  }

  executeTranslation: _notEmpty(value: $__translationPosts)
    @export(as: "executeTranslation")
}

query TranslateData(
  $languageMapping: JSONObject! = {}
)
  @depends(on: "FetchData")
  @include(if: $executeTranslation)
{  
  translatedData: _echo(value: $dataToTranslate)
    @underEachJSONObjectProperty(
      passKeyOnwardsAs: "postID"
      affectDirectivesUnderPos: [1, 2, 3]
    )
      @applyField(
        name: "_objectProperty",
        arguments: {
          object: $translationPostLanguages,
          by: { key: $postID }
        },
        passOnwardsAs: "toLanguage"
      )
      @applyField(
        name: "_objectProperty",
        arguments: {
          object: $languageMapping,
          by: { key: $toLanguage }
          failIfNonExistingKeyOrPath: false
          valueWhenNonExistingKeyOrPath: $toLanguage
        },
        passOnwardsAs: "toLanguage"
      )
      @underEachJSONObjectProperty
        @strTranslate(
          from: $fromLanguage,
          to: $toLanguage
        )
    @export(as: "translatedData")
}

query GenerateMutationInputs(
  $updateSlug: Boolean! = true
)
  @depends(on: "TranslateData")
  @include(if: $executeTranslation)
{  
  postInputs: _echo(value: $translatedData)
    @underEachJSONObjectProperty(
      passValueOnwardsAs: "postTranslatedData"
      affectDirectivesUnderPos: [1, 2, 3, 4, 5]
    )
      @applyField(
        name: "_objectProperty",
        arguments: {
          object: $postTranslatedData,
          by: {
            key: "title",
          }
        },
        passOnwardsAs: "postTranslatedTitle"
      )
      @applyField(
        name: "_if",
        arguments: {
          condition: $updateSlug,
          then: $postTranslatedTitle,
          else: null
        },
        passOnwardsAs: "postMaybeTranslatedSlug"
      )
      @applyField(
        name: "_objectProperty",
        arguments: {
          object: $postTranslatedData,
          by: {
            key: "rawExcerpt",
          }
        },
        passOnwardsAs: "postTranslatedRawExcerpt"
      )
      @applyField(
        name: "_objectProperty",
        arguments: {
          object: $postTranslatedData,
          by: {
            key: "rawContent",
          }
        },
        passOnwardsAs: "postTranslatedRawContent"
      )
      @applyField(
        name: "_echo",
        arguments: {
          value: {
            title: $postTranslatedTitle,
            slug: $postMaybeTranslatedSlug,
            excerpt: $postTranslatedRawExcerpt,
            contentAs: {
              html: $postTranslatedRawContent
            }
          }
        },
        setResultInResponse: true
      )
    @export(as: "postInputs")
}

mutation TranslateClassicEditorPosts(
  $statusToUpdate: CustomPostStatusEnum! = draft
)
  @depends(on: "GenerateMutationInputs")
  @include(if: $executeTranslation)
{
  updateTranslationPosts: posts(filter: { ids: $translationPostIds, status: $statusToUpdate } ) {
    id
    postInput: _objectProperty(
      object: $postInputs,
      by: {
        key: $__id
      }
    )
      @remove
    update(input: $__postInput) {
      status
      errors {
        __typename
        ...on ErrorPayload {
          message
        }
      }
      post {
        id
        title
        rawExcerpt
        rawContent
      }
    }
  }
}
