########################################################################
#
# This Persisted GraphQL query imports posts from a CSV.
#
# It creates a new post with the title, content and excerpt of each post.
# If the author with that username exists locally, it uses it,
# otherwise it replaces it with "admin".
#
# *********************************************************************
# 
# URL params:
#   - url: URL of the CSV
#
########################################################################

query InitializeDynamicVariables
  @configureWarningsOnExportingDuplicateVariable(enabled: false)
{
  postInputs: _echo(value: [])
    @export(as: "postInputs")
    @remove
}

query GetPostsFromCSVAndExportData(
  $url: URL!
  $titleColumn: String! = "title"
  $excerptColumn: String! = "excerpt"
  $contentColumn: String! = "content"
  $authorUsernameColumn: String! = "author"
)
  @depends(on: "InitializeDynamicVariables")
{
  _sendHTTPRequest(input: {
    url: $url,
    method: GET
  }) {
    body
    csv: _strParseCSV(
      string: $__body
    )
    postInputs: _strParseCSV(
      string: $__csv
    )
      @underEachArrayItem(
        passValueOnwardsAs: "csvPostEntry"
        affectDirectivesUnderPos: [1, 2, 3, 4, 5]
      )
        @applyField(
          name: "_objectProperty",
          arguments: {
            object: $csvPostEntry,
            by: {
              key: $titleColumn,
            }
          },
          passOnwardsAs: "postTitle"
        )
        @applyField(
          name: "_objectProperty",
          arguments: {
            object: $csvPostEntry,
            by: {
              key: $excerptColumn,
            }
          },
          passOnwardsAs: "postExcerpt"
        )
        @applyField(
          name: "_objectProperty",
          arguments: {
            object: $csvPostEntry,
            by: {
              key: $contentColumn,
            }
          },
          passOnwardsAs: "postContent"
        )
        @applyField(
          name: "_objectProperty",
          arguments: {
            object: $csvPostEntry,
            by: {
              key: $authorUsernameColumn,
            }
          },
          passOnwardsAs: "postAuthorUsername"
        )
        # Already create (and export) the inputs for the mutation
        @applyField(
          name: "_echo",
          arguments: {
            value: {
              status: draft,
              title: $postTitle,
              excerpt: $postExcerpt,
              contentAs: {
                html: $postContent
              },
              authorBy: {
                username: $postAuthorUsername
              }
            }
          },
          setResultInResponse: true
        )
      @export(as: "postInputs")
}

mutation CreatePostsFromCSVEntries
  @depends(on: "GetPostsAndExportData")
{
  createdPostIDs: _echo(value: $postInputs)
    @underEachArrayItem(
      passValueOnwardsAs: "input"
    )
      @applyField(
        name: "createPost"
        arguments: {
          input: $input
        },
        setResultInResponse: true
      )
    @export(as: "createdPostIDs")
}

query RetrieveCreatedPosts
  @depends(on: "CreatePostsFromCSVEntries")
{
  createdPosts: posts(
    filter: {
      ids: $createdPostIDs,
      status: [draft]
    }
  ) {
    # Fields not to be duplicated
    id
    slug
    date
    status

    # Fields to be duplicated
    author {
      id
    }
    categories {
      id
    }
    rawContent
    excerpt
    featuredImage {
      id
    }
    tags {
      id
    }
    title
  }
}




query GetPostsFromCSVAndExportData(
  $url: URL!
) {
  _sendHTTPRequest(input: {
    url: $url,
    method: GET
  }) {
    body
    csv: _strParseCSV(
      string: $__body
    )

    # Fields to be imported
    authorUsername: _objectProperty(
      object: $__rssJSON,
      by: {
        path: "rss.channel.item.dc:creator"
      }
    )
      @export(as: "authorUsername")

    # categorySlugs: _objectProperty(
    #   object: $__rssJSON,
    #   by: {
    #     path: "rss.channel.item.category"
    #   }
    # )

    content:  _objectProperty(
      object: $__rssJSON,
      by: {
        path: "rss.channel.item.content:encoded"
      }
    )
      @export(as: "content")

    excerpt:  _objectProperty(
      object: $__rssJSON,
      by: {
        path: "rss.channel.item.description"
      }
    )
      @export(as: "excerpt")

    title:  _objectProperty(
      object: $__rssJSON,
      by: {
        path: "rss.channel.item.title"
      }
    )
      @export(as: "title")
  }
}

# If the author's username exists in this site, keep it
# Otherwise, use "admin"
query CheckAuthorExistsOrChange(
  $adminUsername: String! = "admin"
)
  @depends(on: "GetPostsFromCSVAndExportData")
{
  existingUserByUsername: user(by: { username: $authorUsername })
  {
    id
    username
  }
  userExists: _notNull(value: $__existingUserByUsername)
  username: _if(
    condition: $__userExists,
    then: $authorUsername,
    else: $adminUsername
  )
    @export(as: "existingAuthorUsername")
}

mutation ImportPostFromRSSFeed
  @depends(on: "CheckAuthorExistsOrChange")
{
  createPost(input: {
    status: draft,
    authorBy: {
      username: $existingAuthorUsername
    },
    contentAs: {
      html: $content
    },
    excerpt: $excerpt
    title: $title
  }) {
    status
    errors {
      __typename
      ...on ErrorPayload {
        message
      }
    }
    post {
      id
      slug
      date
      status

      author {
        id
        username
      }
      content
      excerpt
      title
    }
  }
}